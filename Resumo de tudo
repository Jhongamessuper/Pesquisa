Teste de software

O teste de software é uma maneira de avaliar a quantidade da aplicação e reduzir o risco de falha em operação.
Testar não consiste apenas em executar testes (executar o software e verificar os resultados).Executar testes é apenas umas das atividades.
Planejamento, análize, modelagem e imprementação dos testes, relatórios de progresso, resultado e avaliação da qualidade, também são partes de um processo de testes.
Testar software não é somente verificar se os requisitos foram atendidos ou se as estórias de usuário, bem como demais especificações, foram contempladas. Atribui-se ao teste de software também a validação, ou seja, verificar se o sistema atenderá às necessidades do usuário e de outras partes interessadas em seu(s) ambiente(s) operacional(s)

Teste dinâmico e estático

O teste dinâmico refere-se à execução de um componente ou sistema. Já os demais, que não envolvem a execução do componente ou sistema, são conhecidos como testes estáticos. Para cada uma destas categorias existem inúmeros tipos de processos. Lembrando que estou seguindo a linha apresentada pelo Syllabus.

São vários os objetivos de se testar um software, independente do projeto. O Syllabus destaca os seguintes:

Avaliar os produtos de trabalho (requisitos, estórias de usuário, modelagem e código);
Verificar se todos os requisitos especificados foram atendidos;
Validar se o objeto de teste está completo e funciona como os usuários e outras partes interessadas esperam;
Criar confiança no nível de qualidade do objeto de teste;
Evitar defeitos;
Encontrar falhas e defeitos;
Fornecer informações suficientes às partes interessadas para permitir que elas tomem decisões, especialmente em relação ao nível de qualidade do objeto de teste;
Reduzir o nível de risco de qualidade de software inadequada (ex.:, falhas não detectadas anteriormente que ocorrem em produção);
Cumprir com requisitos ou normas contratuais, legais ou regulamentares, e/ou verificar o cumprimento do objeto de teste com tais requisitos ou normas.

Testar software não é depurá-lo

As atividades não são sinônimas. O que ocorre é que em alguns casos, os testadores são responsáveis pelo teste inicial e pelo teste de confirmação final, enquanto os desenvolvedores fazem a depuração e o teste do componente associado. Há ainda os contextos ágeis, onde os testadores podem ser envolvidos na depuração e no teste de componente. Em resumo, há uma diferenciação para TESTE e DEPURAÇÃO:

Teste → A execução dos testes pode mostrar falhas causadas por defeitos no software.

Depuração → Atividade de desenvolvimento que localiza, analisa e corrige esses defeitos.

Por que o teste é necessário?

Para reduzir o risco de falhas durante a operação. Isso se dá a partir de testes rigorosos de componentes e sistemas, além do uso de documentação adequada;
Para contribuir com a qualidade dos componentes ou sistemas. Isso se dá a partir da detecção e correção de defeitos;
Para atender aos requisitos contratuais/legais ou aos padrões específicos do setor a que se destinam;

BUG, DEFEITO e FALHA

Uma pessoa pode cometer um erro (engano), que pode levar à introdução de um defeito no código do software ou em algum outro produto de trabalho relacionado.

Um erro que leva à introdução de um defeito em um produto de trabalho pode acionar outro erro que leva à introdução de um defeito em um outro produto de trabalho relacionado.
Exemplo: uma pessoa levanta um requisito de forma incompleta, ambígua, incorreta. Caracteriza-se um erro. O projeto de software daquele requisito é realizado de forma incorreta. Caracteriza-se um defeito. O desenvolvedor cria um código incorreto a partir de um projeto incorreto/errado. Caracteriza-se um erro. O software gerado apresentará defeito devido ao código incorreto.

A execução de um código defeituoso, pode causar uma falha, mas não necessariamente em todas as circunstâncias.
Exemplo: bug do milênio, que ocorreu em uma circunstância específica.

Nem todos os resultados de testes inesperados são falhas. Podem ocorrer falsos positivos (relatos de defeitos que não são defeitos) ou também falsos negativos (testes que não detectam defeitos que deveriam ser detectados).
Falsos positivos podem ocorrer devido a erros na forma como os testes foram executados ou devido a defeito nos dados, no ambiente ou em outro tesware (produtos de teste) ou por outros motivos.

Critérios de aceitação

Os critérios de aceitação funcional dizem como o software precisa se comportar para ajudar seus usuários a fazer seu trabalho. Eles são sobre as funções, ou recursos, que seu software oferece. Os critérios de aceitação não-funcionais especificam os requisitos para tudo mais.

Artefatos de testes

Artefatos de teste são simplesmente parte integrante do teste de software. Geralmente, são conjuntos de documentos que o testador do projeto de software obtém durante o STLC (Ciclo de Vida do Teste de Software). Artefatos de teste são subprodutos gerados ou criados durante a execução de testes de software.

Níveis de teste

Existem vários tipos de testes: Unidade, Integração, Sistema, Aceitação, Regressão, Alfa e Beta.

Unitário

O objetivo do teste unitário é assegurar que cada unidade está funcionando de acordo com sua especificação funcional. Estes tipos de testes são frequentemente escritos por desenvolvedores quando trabalham no código, para assegurar que a função específica está executando como esperado.

Integração

Consiste em módulos que são integrados e testados em grupo. Como por exemplo seu software, acessando um banco de dados ou fazendo uma chamada externa a outros sistemas.
Assim como o teste de unidade, o teste de integração usa as mesmas ferramentas JUNIT, PHPUNIT entre outras.
O teste de integração é executado antes do sistema estar concluído, ao contrário do teste de unidade que é executado após a criação do software.

Sistema
É o processo de testar o sistema por completo. Verificando se os componentes são compatíveis, se eles interagem corretamente e se transferem os dados certos no momento certo. Tem como objetivo executar o software sob o ponto de vista do seu usuário final, realizando o teste do sistema.
Os testes são realizados baseando-se nos documentos de especificações fornecidos daquele sistema. Quando um software é desenvolvido criamos um documento especificando o comportamento do software.
A diferença do teste de sistema é que o teste é realizado após a codificação do sistema estar concluída.

Aceitação
Tem como objetivo executar o sistema sob o ponto de vista do usuário final. O cliente avalia o sistema e após a experiência de utilização tem a responsabilidade de aceitar ou não o sistema que foi entregue e pelo qual foi pago.

Tipo de testes

Testes funcionais
O teste funcional consiste em uma série de subtestes (técnicas), cujo objetivo é atestar se a aplicação é capaz de desempenhar as funções que se propõe a fazer. As técnicas mais comuns englobadas pelo teste funcional são os testes denominados caixa-branca e caixa-preta.
O teste de caixa-branca tem como foco a análise do comportamento interno do software, ou seja, o seu código-fonte. Já o teste de caixa-preta é feito em cima das funções que devem ser desempenhadas pelo programa.

Regressão

O teste de regressão é uma técnica do teste de software que consiste na aplicação de versões mais recente do software, para garantir que não surgiram novos defeitos em componentes já analisados. Se, ao juntar o novo componente ou as suas alterações com os componentes restantes do sistema surgirem novos defeitos em componentes inalterados, então considera-se que o sistema regrediu.

Desempenho

O teste de desempenho é uma classe de testes implementada e executada para caracterizar e avaliar o desempenho relacionado a características do objetivo do teste, como perfis de andamento, fluxo de execução, tempos de resposta, confiabilidade e limites operacionais. Vários tipos de testes de desempenho, cada um concentrado em um objetivo do teste diferente, são implementados durante todo o ciclo de vida de desenvolvimento do software (SCLC). Nas iterações de arquitetura, os testes de desempenho baseiam-se na identificação e na eliminação de gargalos de desempenho relacionados à arquitetura. Nas iterações de construção, outros tipos de testes de desempenho são implementados e executados para ajustar o software e o ambiente (otimizando o tempo de resposta e os recursos) e para verificar se a aceitabilidade dos aplicativos e do sistema consegue lidar com condições de alta carga e stress, como um grande número de transações, clientes e/ou volumes de dados.

Aceitação

O teste de aceitação é um processo de garantia de qualidade (QA). Ele determina em que grau um aplicativo atende à aprovação dos usuários finais. No entanto, dependendo da organização, o teste de aceitação pode assumir a forma de teste beta, teste de aplicativo, teste de campo ou teste do usuário final.

Fumaça (smoketest)

Testes de fumaça são testes básicos que verificam as funcionalidades básicas do aplicativo. Eles devem ser rápidos para executar, e seu objetivo é dar-lhe a garantia de que as principais características do seu sistema estão funcionando como esperado.

Exploratório

O teste exploratório consiste em design de teste e execução do teste ao mesmo tempo. Isso é o oposto de teste com script (procedimentos de teste predefinidos, manuais ou automatizados). Diferentes dos testes com script, os testes exploratórios não são definidos previamente e executados com exatidão conforme o plano.

Confirmação

Para isso é utilizado o Teste de confirmação (depois que um defeito é corrigido, o software pode ser testado com todos os casos de teste que falharam devido ao defeito).

Estresse

Testes de estresse são usados para garantir a estabilidade e a confiabilidade do sistema. Os testes simulam uma alta taxa de dados e de tráfego e registram como o sistema responde nestas condições. É um dos testes mais importantes para garantir o sucesso das vendas, especialmente nas datas comerciais.
Durante o teste de estresse, o software testado receberá uma alta carga de tráfego para saber o limite, até quando o software ou hardware suportarão. Isso permite melhorar o dimensionamento de infra, detectar scripts demasiadamente pesados e ter mais eficácia no gerenciamento de erros sob condições extremas.

Carga

O teste de carga de definição geralmente refere-se ao teste como um subconjunto do processo de teste de desempenho de software, que normalmente também inclui vários outros tipos de testes, como testes de estresse, testes de imersão, testes de pico, testes de resistência, testes de volume e testes de escalabilidade.

Volume

O teste de volume também é chamado de teste de inundação e é um tipo de teste de desempenho. carga é um tipo de teste de software executado para testar o desempenho ou comportamento do sistema sob a carga esperada do mundo real. O teste de carga também é um tipo de teste de desempenho.

Recuperação

O objetivo do backup é manter a disponibilidade e continuidade dos serviços para que as operações não sejam interrompidas. Por isso, eles precisam ser eficientes e monitorados constantemente. Assim, os possíveis problemas podem ser detectados com facilidade, antes que algum erro grave aconteça.

Segurança

Teste de segurança é um tipo de teste de Software que descobre vulnerabilidades, ameaças, riscos em um aplicativo de software e evita ataques maliciosos de intrusos.

Manual e automatizados

O teste automatizado é adequado quando os casos de teste precisam ser executados repetidamente por um longo período de tempo. O teste manual ajuda a descobrir a facilidade de uso de um aplicativo. Envolve observação humana para descobrir quaisquer falhas.

Técnicas de modelagem de teste

Caixa braca e preta

A técnica de teste de caixa branca é conhecida por vários nomes tais como teste estrutural e teste de caixa de vidro. O engenheiro de sistema realiza o teste direto no código fonte do software. São determinados os dados de entrada para analisar a lógica do software.

A desvantagem da técnica de caixa de caixa branca é que não analisa se a especificação esta certa, concentra apenas no código fonte e não verifica a lógica da especificação.

O teste de caixa preta pode ser também chamado de teste funcional! Diferente do teste de caixa branca, ele possui esse nome porque o código-fonte é ignorado no teste. Assim, ao se utilizar dessa técnica, o tester não está preocupado com os elementos constitutivos do software, mas em como ele funciona.

Métodos de teste

Step-by-step(passo a passo)

Fazer e ver tudo que fez cada detalhe.

Pairwise

A técnica de Pairwise consiste em testar um software sem ter que utilizar 100% das possibilidades de variações existentes, o que em determinados casos pode gerar anos de execução de casos de teste.

Gráfico de causa e efeito

O Diagrama de Causa e Efeito também conhecido como Diagrama de Ishikawa é uma ferramenta de análise de processos e uma das 7 Ferramentas da Qualidade. Tem como objetivo principal representar a relação entre um “efeito” e suas possíveis “causas”.

Classe de equivalência e valores limites

O teste com base na análise de classe de equivalência (sinônimos: particionamento de equivalência, análise de domínio) é uma forma de análise de teste de caixa preta que tenta reduzir o número total de testes possíveis para um conjunto mínimo de testes que revelarão o número máximo de erros possível
A técnica nos diz que devemos testar um valor imediatamente abaixo do que o limite, o valor limite e um valor imediatamente acima do valor limite. Com isso, temos os casos de teste para esse intervalo numérico conforme a técnica análise de valor limite.

Ferramentas de testes

Mantis

Mantis Bug Tracking é uma ferramenta WEB open source, desenvolvida em PHP, customizável e totalmente balanceada entre simplicidade e desempenho para controle de bugs. Essa ferramenta suporta muitos sistemas de banco de dados, são eles: MySQL, MS SQL, PostgreSQL e DB2.

TestLink 

Funcionalmente, a ferramenta permite que sejam cadastrados Projetos de Teste, bem como seus respectivos Planos e Casos de testes à serem validados. Então, a partir da definição do escopo do projeto de teste, é possível controlar e armazenar a execução dos casos de teste especificados.

JUnit 

O JUnit é um framework open-source, que se assemelha ao raio de testes software java, criado por Erich Gamma e Kent Beck, com suporte à criação de testes automatizados na linguagem de programação Java. Esse framework facilita a criação e manutenção do código para a automação de testes com apresentação dos resultados.

Selenium

Selenium é um conjunto de ferramentas de código aberto multiplataforma, usado para testar aplicações web pelo browser de forma automatizada. Ele executa testes de funcionalidades da aplicação web e testes de compatibilidade entre browser e plataformas diferentes.

Ghost Inspector

O Ghost Inspector é uma ferramenta de monitoramento e teste automatizado baseada em nuvem. Você pode pensar nele como uma ferramenta avançada de gravação e playback. O Ghost Inspector fornece plugins do Google Chrome e Firefox para gravar ações do navegador e permitir aos usuários salvar os testes em uma plataforma de nuvem. A melhor parte, contudo, é a capacidade de configurar as notificações e agendar testes, além de outras configurações relacionadas. A outra vantagem sobre a ferramenta é que os testes são muito estáveis e não sofrem com a falta de confiabilidade do Selenium Webdriver.

Estratégias de teste

Preventiva e reativa.

Abordagem Preventiva
Equipe de Testes é envolvida desde o início: planejando as atividades de teste e especificando as atividades de teste são cedo quando possível. Isto pode ocasionar a otimização das atividades de teste e consequente redução de custo, já que os bugs de expecificação e projeto serão encontrados cedo, gerando menos retrabalho. Aplicação de revisão e análise estática antes do desenvolvimento pode contribuir para prevenir defeitos em tempo de execução de testes. Desta forma, pode-se reduzir os custos com execução de testes e retrabalho.

Abordagem Reativa
São atividades nas quais a equipe de testes é envolvida muito tardiamente e a abordagem preventiva não pôde ser escolhida. Nesta situação a análise e projeto do sistema já foi concluído, de tal forma que a equipe de testes precisará ‘explorar’ as funcionalidades a ser entregues. Testes exploratórios são baseados na experiência dos testadores e têm como objetivo executar diversas possibilidades de execução e de avaliação.

Gestão de defeitos

Causas

Um processo de gestão de defeitos tem o objetivo de definir práticas para prevenir os defeitos e minimizar os riscos de um projeto. A utilização de uma ferramenta automatizada, além de oferecer uma base comum para a entrada de informações, também oferece um meio para fomentar a integração entre o time de desenvolvimento e o time de testes. Além disso, por meio dos relatórios de gestão e métricas geradas por essas ferramentas, os gestores do projeto poderão promover a melhoria contínua do processo estabelecido.

Genericamente, o termo Erro (Error) é utilizado para indicar uma diferença entre valor computado, observado ou medido em relação ao esperado. No entanto, o padrão IEEE 610.12-1990 (IEEE Standard Glossary of Software Engineering Terminology) distingue a terminologia da seguinte forma:

Defeito (Fault): Passo, processo ou definição de dados incorretos. Por exemplo, uma instrução incorreta no código ou uma falta num artefato estático;
Engano (Mistake): Ação humana que produz um resultado incorreto, como por exemplo, uma ação incorreta tomada pelo desenvolvedor ou analista;
Falha (Failure): Desvio entre o resultado/comportamento apresentado pela aplicação em relação aos requisitos. A falha ocorre em conseqüência de um erro, defeito ou engano gerando um comportamento incorreto da aplicação.

Ciclo de vida

Como discutimos anteriormente, a qualidade de um sistema pode ser medida, essencialmente, pelo número de defeitos encontrados durante a execução dos testes.

Podemos afirmar que os defeitos são encontrados por meio da execução formal dos testes (testes estruturais ou funcionais), durante a utilização do sistema em produção ou, até mesmo, por acidente. A priori, podemos classificar os defeitos nas seguintes categorias:

Faltante (Missing): O defeito ocorre em virtude da falta parcial ou total de um requisito;
Errado (Wrong): O defeito ocorre porque o requisito foi implementado incorretamente;
Acréscimo (Extra): O defeito ocorre em virtude de um comportamento ou elemento que foi implementado, mas foi não especificado no requisito.
Uma vez que o defeito for encontrado, seja por intenção ou por acidente, o próximo passo deverá ser o relato (ou reporte) desse defeito por meio de algum mecanismo estabelecido no processo de gestão de defeitos.

Este mecanismo poderá ser, desde uma simples planilha, até uma ferramenta automatizada. Por motivos óbvios, uma ferramenta automatizada e construída para esse propósito será, sem sombra de dúvida, muito mais eficiente do que uma simples planilha ou solução alternativa.

De qualquer forma, tão logo o defeito seja relatado, ele deverá ser submetido a um ciclo de vida pré-definido pelo processo de gestão de defeitos. Este ciclo de vida define os fluxos que o defeito deverá percorrer até o seu fechamento.

Consequência



regra 10 de Myers.

A regra 10 de Myers apresenta que o custo da correção de um defeito tende a aumentar quanto mais tarde ele for encontrado. Os defeitos encontrados nas fases iniciais do projeto de desenvolvimento do software são mais baratos do que aqueles encontrados na produção.

Plano de Teste



Elaboração

O plano de teste, que pode ser elaborado pelo gerente de projeto ou gerente de testes, visa planejar as atividades a serem realizadas, definir os métodos a serem empregados, planejar a capacidade necessária, estabelecer métricas e formas de acompanhamento do processo.

Especificações

Trata-se de um documento ou mapa no qual se definem escopo e objetivos, além de requisitos, estratégias e recursos a serem empregados nas atividades de testes de software. Nesse sentido, o artigo apresenta os itens que devem fazer parte de um documento de plano de teste, exemplificando e discutindo esses itens.

Tipos de teste a serem executados no procedimento

Teste funcional,Teste regressivo,Teste exploratório,Teste de segurança,Teste de Performance.

Registros de teste

Trata-se de um documento ou mapa no qual se definem escopo e objetivos, além de requisitos, estratégias e recursos a serem empregados nas atividades de testes de software.








